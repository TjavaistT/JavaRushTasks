package com.javarush.task.task15.task1526;

/*
* Яркий пример того, что наследовние с переопределением намного сложней, чем кажется -
* потому что необходимо помнить порядок выполнения кода при создании дочернего объекта:
*
* 1. инициализируются статические поля родительского класса (и выполняются статические блоки)
* 2. инициализируются статические поля дочернего класса (и выполняются статические блоки)
* 3. инициализируются не статические поля родительского класса (и выполняются не статические блоки)
* 4. выполняется конструктор родительского класса
* 5. инициализируются не статические поля дочернего класса (и выполняются не статические блоки)
* 6. выполняется конструктор дочернего класса
*
* ! Если в областях или конструкторе родителя вызываются переопределенные функции, то они выполнятся в дочернем классе!
*
* И что не следует подключать методы в конструкторе
*
Дебаг, дебаг, и еще раз дебаг
*/

public class Solution {
    public static void main(String[] args) {
        new B(6);
    }

    public static class A {
        private int f1 = 7;

        public A(int f1) {
            this.f1 = f1;
            //проблема данного кода в том, что метод переопределен в классе B и он выполнится в классе B
            initialize();
        }
        //чтобы этот метод выполнялся от имени класса А, нужно разорвать переопределение
        // для этого делаем этот метод с модификатором private
        private void initialize() {
            System.out.println(f1);
        }
    }

    public static class B extends A {
        protected int f1 = 3;

        public B(int f1) {
            super(f1);
            this.f1 += f1;
            initialize();
        }

        // конструктор класса А вызывает этот метод из класса B
        // естественно до класса B еще не дошел порядок выполнения и все его поля - пусты
        // и функция отработает некорректно
        protected void initialize() {
            System.out.println(f1);
        }
    }
}
