

    JavaRush
    Курс
    Задачи
    Игры
    Опросы
    Помощь
    Подписки
    Истории успеха
    Чат
    Форум
    Группы
    Друзья
    Сообщения
    Стажировка
    Активность

Курс Java

    Валентин
    22 уровень
    1140

File, Files, Path
Java Collections
1 уровень, 1 лекция

— Привет, Амиго. Давно не виделись.

— Привет, Билаабо. О чем будешь рассказывать?

— Сегодня я расскажу о работе с файлами. В Java есть специальный класс (File), с помощью которого можно управлять файлами на диске компьютера. Для того чтобы управлять содержимым файлов, есть другие классы: FileInputStream, FileOutputStream,…
File, Files, Path - 1

— Интересно. А когда ты говоришь «управлять файлами», что ты имеешь в виду?

— Как раз сейчас и расскажу. Файлы можно создавать, удалять, переименовывать и еще много чего. В практически все классы, которые работают (читают, пишут, изменяют) с содержимым файла, можно передавать объект класса File. Пример:
Можно сразу передавать имя файла в FileInputStream

FileInputStream input = new FileInputStream("c:/path/a.txt");

А можно отдельно создать объект-файл, а потом передать его в FileInputStream

File file = new File("c:/path/a.txt");
FileInputStream input = new FileInputStream(file);

— Но во втором случае длиннее же получается. Так и не понял – зачем эти файлы нужны.

— Для этого конкретного случая – да. Это не пример, как надо делать, а скорее – как можно.
Но вот представь, что тебе нужно вывести на экран список всех файлов, которые находятся в определенной директории (папке). Вот как это можно сделать с помощью файлов:
Код

File folder = new File("c:/path/");
for (File file : folder.listFiles())
{
 System.out.println(file.getName());
}

— listFiles() – это метод, который возвращает список файлов в папке с именем «c:/path/»?

— Да. Хотя программисты обычно говорят «директория» или «каталог». Название «папка» стало употребляться совсем недавно, но, в принципе, они все верные, и ты можешь говорить, как тебе удобнее.

— Ок. А getName() что делает? Выдает имя файла? И какое именно имя? Полное вместе с путем или только имя самого файла?

— Только имя самого файла. Для полного есть file.getAbsolutePath()

— А какие еще методы есть у класса File?

— Вот, смотри:
Метод 	Описание
boolean isDirectory() 	Является ли «объект файла» директорией
boolean isFile() 	Является ли объект файлом
long length() 	Возвращает размер/длину файла в байтах.
boolean createNewFile() 	Создает файл. Если такой файл уже был, возвращает false.
boolean mkdir() 	Создает директорию. Название mkdir происходит от «make directory».
boolean mkdirs() 	Создает директорию и все поддиректории.
boolean delete() 	Удаляет файл объекта на диске. Если объект – директория, то только, если в ней нет файлов.
void deleteOnExit() 	Добавляет файл в специальный список файлов, которые будут автоматически удалены при закрытии программы.
File createTempFile(
String prefix,
String suffix,
File directory) 	Создает «временный файл» — файл с случайно сгенерированным уникальным именем – что-типа «dasd4d53sd».
Дополнительные параметры – префикс к имени, суффикс (окончание). Если директория не указана, то файл создается в специальной директории ОС для временных файлов
boolean exists() 	Возвращает true, если файл с таким именем существует на диске компьютера.
String getAbsolutePath() 	Возвращает полный путь файла со всеми поддиректориями.
String getCanonicalPath() 	Возвращает канонический путь файла.
Например, преобразовывает путь «c:/dir/dir2/../a.txt» к пути «c:/dir/a.txt»
String[] list() 	Возвращает массив имен файлов, которые содержатся в директории, которой является текущий объект-файл.
File[] listFiles() 	Возвращает массив файлов, которые содержатся в директории, которой является текущий объект-файл.
long getTotalSpace() 	Возвращает размер диска (количество байт) на котором расположен файл.
long getFreeSpace() 	Возвращает количество свободного места (количество байт) на диске, на котором расположен файл.
boolean renameTo(File) 	Переименовывает файл – содержимое файла фактически получает новое имя. Т.е. можно переименовать файл «c:/dir/a.txt» в «d:/out/text/b.doc».
String getName() 	Возвращает только имя файла, без пути.
String getParent() 	Возвращает только путь (директорию) к текущему файлу, без самого имени.
Path toPath() 	Возвращает объект Path, который соответствует текущему объекту File.

— Ничего себе! А немаленький такой список получился. Да и вроде, можно довольно много сделать с помощью него: создавать, удалять файлы, переименовывать,…

А чтобы получить директорию текущего файла, надо вызвать getParent()?

— Ага, но он вернет не объект-файл, а строку – путь к файлу. Фактически у класса File почти все методы дублированы: одна версия возвращает String, вторая File. Вот смотри:

File file = new File("c:/path/a.txt");
String directory = file.getParent();

File file = new File("c:/path/a.txt");
File directory = file.getParentFile();

Если у тебя есть строка с путем к файлу, а надо объект File, то воспользуйся конструктором. Если же наоборот – есть объект File, а нужна строка – используй getAbsolutePath(). Пример:

String path = "c:/a.txt";
File file = new File(path);

File file = new File("c:/a.txt");
String path = file.getAbsolutePath();

— Понял.

— Отлично. Тогда вот тебе маленькое задание – выведи имена всех файлов, которые есть в той же директории, что и текущий файл.

— Нет ничего проще, вот, смотри:
Код

//какой-то текущий файл
File originalFile = new File("c:/path/dir2/a.txt");

//объект-директория
File folder = originalFile.getParentFile();

//печать списка файлов на экран
for (File file : folder.listFiles())
{
 System.out.println(file.getName());
}

— Гм. Правильно.

— А то! Немного путает, что и для файла и для директории используется один и тот же класс – File. Как то это не очень логично, мне кажется.

— Так исторически сложилось. Раньше директория была специальным «пустым» файлом на диске. Сейчас уже, конечно, многое изменилось, но не везде. У меня на сегодня все.

— Спасибо, за отличную лекцию, Билаабо.

+41
Комментарии (35)
Валентин
Максим Чернявский32 уровень, Санкт-Петербург
3 июля, 18:39
Ну наконец-то нормальная лекция.
Ответить
+4
Hexronimo23 уровень
2 июля, 21:30
Если закрыть программу во время исполнения темп-файл ведь останется?
Ответить
0
Даниил34 уровень
6 июля, 12:34
Та вроде нет.
Ответить
0
Hexronimo23 уровень
14 июля, 16:50
Судя по публикациям на стэковерфлоу, остаются, но есть разные методы по их удалению. Я конечно имею в виду принудительное завершение программы, например, с xkill.
Ответить
+1
Aleks25 уровень, Москва
22 апреля, 13:58
Не понял, чем отличается AbsolutePath от CanonicalPath ?!
Ответить
0
Макс26 уровень, Киев
11 мая, 19:57
http://qaru.site/questions/325641/whats-the-difference-between-canonicalpath-and-absolutepath
Ответить
+1
Vitaly Khan37 уровень
26 января, 03:43
обратите внимание, что несмотря на то, что в Windows разделитель директорий в пути - обратный слэш ("\"), в строковом представлении путей в Джава можно использовать универсальный разделитель - прямой слэш ("/"), он же - знак операции деления.
Ответить
+8
Ярослав40 уровень, Днепр
22 мая 2018, 08:52
Челлендж "объясните канонизированный путь" принят.

Есть у нас путь:
d:/d1/d2/../file.txt

Команда .. означает, что мы хотим вернуться в последнюю папку.

Таким образом, мы входим в папку d1, входим в папку d2, а потом возвращаемся в d1, а там уже ищем файл.

Заходить в d2 и возвращаться обратно не было никакого смысла. Канонический путь вырезает такие бесполезные команды и оставляет только настоящий, короткий путь.

.. - обозначает родительский каталог.
. - обозначает текущий каталог.
Ответить
+16
Максим40 уровень
2 октября 2018, 07:03
понятно зачем обозначать родительский каталог, а вот зачем обозначать текущий, можете привести пример как это работает?
Ответить
0
Ярослав40 уровень, Днепр
2 октября 2018, 14:19
Честно: не знаю. По идее, можно писать без обозначения текущего каталога. В это можно не углубляться. Если когда-нибудь это нужно будет - вы вспомните)
Ответить
0
Максим40 уровень
22 октября 2018, 01:49
Можно использовать при некоторых консольных командах в линуксе. Например, чтобы полностью не прописывать путь
Ответить
0
Дмитрий Зорин35 уровень
25 октября 2018, 01:22
/c/somedir1/somedir2 - путь относительно корня ФС
./c/somedir1/somedir2  - путь относительно текущего расположения
Ответить
+3
Вадим Власов39 уровень
22 февраля 2018, 11:30
может мне кто объяснить следующее: boolean renameTo(File)

Переименовывает файл – содержимое файла
фактически получает новое имя. Т.е. можно
переименовать файл «c:/dir/a.txt» в «d:/out/text/b.doc».



означает ли, что после переименования файл будет перенесен в новое место, согласно его имени?
Ответить
+7
Сергей Черник40 уровень
28 февраля 2018, 15:44
Да, этой командой можно не только переименовывать, но и перемещать файлы!
Ответить
+16
Andrei Kharybin36 уровень
10 сентября 2017, 20:18
Кто может простым языком в двух словах объяснить, что такое канонизированный путь, как это работает, откуда взялось и где применяется?
Ответить
+7
Kroll36 уровень, Владивосток
9 октября 2017, 10:34
Когда у тебя путь C:\dir1\file.txt это канонизированный путь, т.е. кратчайший от корня диска до файла.
А вот путь C:\dir1\dir2\dir3\..\..\file.txt это путь до того же самого файла в том же каталоге, но склеенный из абсолютного текущей директории C:\dir1\dir2\dir3, когда ты в ней сидел, и относительного  путя до того же файла изнутри этой же текущей директории. Такой полный путь содержит лишние телодвижения сначала бесполезно забираясь на два уровня ниже, а потом поднимаясь обратно выше на два уровня. Канонизация просто вырежет "dir2\dir3\..\..\" сделав путь кратчайшим.
Ответить
+13
Маша Кутневич24 уровень, Bremen
6 ноября 2017, 15:00
интересно, одна я так и не поняла это объяснение
Ответить
+25
Сергей Бычков31 уровень
6 ноября 2017, 23:19
Я тоже из этого объяснения ничего не понял.
Ответить
+1
Donatello32 уровень
13 декабря 2017, 14:44
Вам бы речи политикам писать :)
Ответить
+4
Антон Никольский33 уровень, Москва
20 декабря 2017, 17:54
Как я понимаю, в UNIX есть специальная команда, которая может "привязать" файл к другому каталогу. Соответственно, один и тот же файл может числиться в разных каталогах с разными путями. Здесь и здесь подробнее.
Ответить
+2
Volodymyr Shtoda40 уровень
27 декабря 2017, 22:00
когда вы находитесь на пол пути к искомому файлу, (где-то в промежуточной папке), скажем, структура такая: c:\папка1\папка2\папка3\искомыйФайл.java, и вы смотрите на структуру с позиции "папка2", то
абсолютный путь будет такой: c:\папка1\папка2\папка3\искомыйФайл.java,
относительный будет такой: папка3\искомыйФайл.java, но при получении этого пути компьютер может наделать внутри финтов, по типу: \папка2\папка1\с:\папка1\папка2папка3\искомыйФайл.java, то есть, сперва возвращаясь к корню, затем двигаясь вперед к target(искомыйФайл.java), от чего страдает продуктивность работы, канонизация преобразует путь к оптимальному, вырезая ненужные участки
Ответить
+28
Антон Никольский33 уровень, Москва
28 декабря 2017, 18:21
Мне любопытно, как компьютер по записи "\папка2\папка1\с:\папка1\папка2папка3\искомыйФайл.java" понимает, что первое включение "папка1" -  это движение по дереву вверх, а второе включение "папка 1" - движение по дереву вниз.
Ответить
0
Anonimus1506331 уровень
13 марта 2018, 18:36
папка2\.. - выход в родительскую папку, а
папка2\папка3 - вход в дочернюю папку
т.е правильнее запись будет выглядеть так:
\папка2\..\..\папка1\папка2папка3\искомыйФайл.java
Ответить
+9
swen92240 уровень
13 апреля 2018, 16:58
Спасибо, абсолютно точный и понятный ответ! Не знаю, почему некоторые ругаются, что непонятно. Только по вашему комменту понял, что за пустые "прогалы" в пути типа "\..\.." – это же символы выхода на уровень выше!
Ответить
+6
Иван Луценко28 уровень
19 августа 2017, 00:34
А мне жалко Билаабо. Он лучше всех объясняет, но у него нет друзей.
Ответить
+24
Геннадий Шевченко32 уровень
4 октября 2017, 18:46
мы его новый друзья!
Ответить
+2
Anonymous #119486932 уровень
17 ноября 2017, 11:42
С какой стати у него нет друзей ?? Кто сказал ?
Ответить
+2
NastyaGermanovich35 уровень, Санкт-Петербург
23 мая 2018, 12:32
ты его друг?)
Ответить
+1
Rihard198533 уровень
15 сентября 2018, 15:05
Не надо было свой Pascal пропагандировать на начальных уровнях. Он теперь изгой. Как в том фильме с Томом Хенксом
Ответить
+3
Vladislav40 уровень, Москва
1 июля 2017, 15:07
в 21-25 уровенькуча заданий было на эту тему. Теперь понимаю зачем так сделали, что сначала задают задания потом лекции. Сейчас читаю и все это понимаю, так как уже изучил доку во время заданий.
Ответить
+2
MaxLich40 уровень, Санкт-Петербург
27 июня 2017, 14:23
"В практически все классы" - грамотнее будет "Практически во все классы"
Ответить
+1
Volodymyr Shtoda40 уровень
15 января 2018, 00:48
хорошо что понятие "класс" не  мигрировало во что нибудь иное, это же послание из будущего, у них там другое всё
Ответить
+2
JavaRush
Программистами не рождаются
© 2019
